# Rotating Bipolar Footpoints in MPI-AMRVAC

This repository contains a full 3D solar MHD setup for MPI-AMRVAC, modeling a bipolar magnetic configuration generated by two sub-photospheric magnetic charges and driven by two time-dependent rotating footpoints at the lower boundary. The magnetic field is initialized exclusively through a vector potential to ensure ∇·B = 0 via constrained transport.

The setup includes a stratified solar atmosphere, background heating, gravitational stratification, time-dependent boundary driving, and refinement control near the photosphere.

---

# 1. Physical Overview

## Bipolar Magnetic Field (Vector Potential Initialization)

Two virtual magnetic charges are located at:

- `charge1_x = (-L_para, 0, -d_para)`
- `charge2_x = (+L_para, 0, -d_para)`

The vector potential **A(x)** for both charges is computed in `bipolar_field`, and AMRVAC constructs **B = ∇×A** via constrained transport. No explicit direct B-initialization is used.

---

## Solar Atmosphere

A 1D hydrostatic atmosphere is constructed in `inithdstatic`, producing arrays:

- `ya(j)` — height coordinate
- `ra(j)` — density
- `pa(j)` — pressure

These values are interpolated to the bottom boundary ghost cells to maintain atmospheric stability.

---

## Rotating Footpoints

Two circular rotating regions are positioned directly above the magnetic charges:

- Rotation angular velocity defined by  
  `Omega_footpoint = 2π / Period_footpoint_hours`
- Radius of full rotation: `R_footpoint`
- Smooth spatial decay: `R_foot_decay`
- Offsets between charge and rotating center: `Footpoint_dX`

For each cell, the rotation driver computes:

- Pure rotation velocity `(vx, vy)`
- Radial fade coefficient using a quintic smoothstep
- Time-dependent modulation via `time_fade(t)`

The total imposed velocity is a combination of:

- Footpoint 1 rotation (weighted)
- Footpoint 2 rotation (weighted)
- Reflected velocity (when not inside a rotating region)

Vertical velocity is always reflected.

---

## Time Evolution of Driving

The global driving coefficient uses four user-defined time intervals:

- `DT_cold_start` — rotation = 0
- `DT_fade_in` — smooth transition from 0 → 1
- `DT_rotation` — rotation = 1
- `DT_fade_out` — smooth transition from 1 → 0

All times in `&usr_list` are specified in **hours** and automatically converted to AMRVAC time units.

---

# 2. Code Structure (mod_usr.t)

### Initialization
- `usr_init` — Registers all user routines
- `params_read` — Reads `&usr_list` parameters
- `initglobaldata_usr` — Sets units, charges, rotation parameters
- `initonegrid_usr` — Initializes magnetic field, density, pressure
- `initvecpot_usr` — Supplies A(x) for CT
- `bipolar_field` — Computes vector potential for both charges

### Solar Atmosphere
- `inithdstatic` — Builds density and pressure tables
- `getggrav`, `gravity` — Vertical gravitational acceleration

### Boundary Conditions
The key component is `specialbound_usr`:

- Handles all six physical boundaries
- **Case 5: bottom boundary**
  - Applies time-dependent rotating velocity driver
  - Mirror-profile for nondriven areas (`V_bounday = -V_phys_region` so `V_surface == 0`)
  - Atmosphere tables for density/pressure stratification
  - Preserves divergence-free B through compatible extrapolation

### Additional Physics
- `specialsource` / `getbQ` — Background heating term
- `special_refine_grid` — Forces max refinement at the lower boundary
- `specialvar_output` — Adds auxiliary diagnostics:
  - Alfvén speed  
  - divB  
  - plasma beta  
  - current density components  
  - Lorentz force components

---

# 3. Runtime Parameters (amrvac.par)

### Mesh & Domain

# Mesh and Domain Resolution

The simulation uses **unit_length = 1×10⁹ cm = 10 Mm**, so **1 unit_length = 10⁹ cm = 10 Mm**.

The computational domain is:

- **x ∈ [−6 , 6]**
- **y ∈ [−6 , 6]**
- **z ∈ [ 0 , 12]**

Thus each direction spans **12 unit lengths**, corresponding to **120 Mm** physically.

With **domain_nx1 = domain_nx2 = domain_nx3 = 40**, the base-grid resolution (level 1) is:

\[
\Delta x = \frac{12}{40} = 0.3 \text{ unit_lengths}
\]

Since 1 unit_length = 10 Mm:

\[
0.3 \times 10 \text{ Mm} = 3 \text{ Mm per cell}
\]

### Level-1 Resolution (Base Grid)

| Direction | Range (unit_length) | Cells | Δ (unit_length) | Δ (Mm) |
|----------|---------------------|-------|-----------------|---------|
| x | 12 | 40 | 0.3 | 3 Mm |
| y | 12 | 40 | 0.3 | 3 Mm |
| z | 12 | 40 | 0.3 | 3 Mm |

### With AMR (refine_max_level = 3)

\[
\Delta x_L = \frac{0.3}{2^{(L-1)}}
\]

- **Level 1:** 0.3 unit_length = 3 Mm  
- **Level 2:** 0.15 unit_length = 1.5 Mm  
- **Level 3:** 0.075 unit_length = 0.75 Mm  ! **Resolution For Atmosphere Should be better than 1 Mm**  


### Physical Features

- `mhd_energy = .true.`
- `mhd_gravity = .true.`
- Thermal conduction & cooling disabled (for efficient computing)  


### User Parameters (`&usr_list`)  

- R_footpoint (cm)
- R_foot_decay (cm)
- Period_footpoint_hours (h)
- L_para (cm)
- d_para (cm)
- Footpoint_dX (cm)
- DT_cold_start (h)
- DT_fade_in (h)
- DT_rotation (h)
- DT_fade_out (h)

(see above)

# 4. Run experiments  

### Running on a Cluster (1 Node)

- **`compile_amrvac.sh`** — builds MPI-AMRVAC with the correct configuration  
- **`run_amrvac.sh`** — submits or launches the simulation on a single node  

### Manual Compilation on Any Machine

```bash
make clean
make allclean
setup.pl -d=3        # generate 3D configuration
make -j8            # compile with 16 threads
```

```bash
mpirun -np 16 ./amrvac -i amrvac.par
```

# 5. Hints from Ze Zhong  

### Small values fixing  

Small density and pressure values should be used for fixing errors.  
These values should be physically meaningful. For example, the lowest values from hydrostatic solution,
should be chosen minval(pa) for pressure and minval(ra) for density. We expect these quantities rho and p,
shouldnot be lower than these values.  

Small values guide presented here [Small values options in MPI-AMRVAC](https://amrvac.org/md_doc_2smallvalues.html)  

1. Look at the output of initial experiment. Relevant code is here:  
`mod_usr.t :: inithdstatic`  

```fortran
if (mype==0) then
    print*,'minra (min atmospheric density)',minval(ra)  ! later used for small_density in .par
    print*,'minpa (min atmospheric pressure)',minval(pa)  ! later used for small_pressure in .par
    print*,'maxTa',Ta(jmax)
    print*,'rhob',rhob
    print*,'pb',pb
endif
```

Then, replace `small_density` with `minra`, and `small_pressure` with `minpa` in your `.par` file.  

Practically, experiment with `error_fix_1.par` can show the place, where small_value error occured. 
Typically, `error_fix_2.par` should solve the problem.  
`error_catch.par` suggested by AMRVAC documentation to initially check for small values errors.  

### Resume simulation  
[AMRVAC filelist params](https://amrvac.org/md_doc_2par.html#par_filelist)  
Check `restart_from_file` field.  

### Adaptive refinement via own criteria  
Find guides in AMRVAC. Reference part of code for boundary refinement is here:  

`mod_usr.t :: special_refine_grid`  

```fortran
! fix the bottom layer to the highest level
if (block%is_physical_boundary(5)) then
    refine=1
    coarsen=-1
endif
```  

Refinement level up to 5 is plausible for final experiment.  

### Relevant model  
Titov & Démoulin (1999)  

### Higher Magnetic Field  
Need to work on hydrostatic model, becaus dt depends of `V_Alfven`. In current athmosphere model
we include a wide range of densities (transition region and higher corona). Maybe it is better to simulate
dynamics in separate regions (corona vs. chromosphere), and then renormalize density units. Now number_density defined by Hydrogen mass.  

### Thermal conduction  
It is slow compute speed when `thermal_conduction` and `radiative_cooling` turned on in `.par`. 

### Bottom boundary indices  
Ghost layers coordinates defined via ixO. ixOmax3 -- max Z-index of ghost layer, ixOmin3, min Z-index of ghost layer (bottom). Physical region starts from `ixOmax + 1`.
